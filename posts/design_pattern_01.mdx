---
title: 01. 디자인패턴 
description: 디자인패턴
date: 2024-06-17
---
## 객체지향 기초
- 추상화
- 캡슐화
- 다형성
- 종속

## 객체지향 원칙
1. 바뀌는 부분은 캡슐화 한다.
2. 상속보다는 구성을 활용한다. 
  - (서브클래스를 만드는 방식으로 행동을 상속받으면 그 행동은 컴파일할때 완전히 결정됨. 모든 서브클래스에서 똑같은 행동을 상속받아야 함. 하지만 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있음. )
  - 구성을 활용하면 객체에 여러 임무를 새로 추가할 수 있음. 슈퍼 클래스 코드를 수정하지 않고 내용을 추가할 수 있음. 
3. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
4. 상호작용하는 객체 사이에서는 가능한 느슨한 결합을 사용한다.
5. 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다. (OCP: OPEN CLOSE PRINCIPLE)
6. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다. 

## 객체지향 패턴
###  전략 패턴 : 
- 전략패턴은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줌.
- 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음. 


###  옵저버 패턴 : 
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 (one-to-many) 의존성을 정의함.


### 데코레이션 패턴 :
객체에 추가 요소를 동적으로 더할 수 있습니다. 데코레이터를 사용하면 서브클래스르 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다. 

### 팩토리 메서드 패턴 : 
팩토리 메서드 패턴에서는 객체를 생성할 때 필요한 인터페이스(유연성 확장성)를 만듭니다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정합니다. 팩토리 메서드 패턴을 이용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 됩니다 (바뀌는 부분을 캡슐화 하기 )
- 팩토리 메서드 패턴은 상속을 활용합니다.
- \# 캡슐화 , 의존성 뒤집기, 느슨한 결합

_의존성 뒤집기 원칙_
1. 변수에 구상클래스의 레퍼런스를 저장하지 맙시다.
    - new 연산자를 사용하면 구상 클래스의 레퍼런스를 사용하게 됩니다. 그러니 팩토리를 써서 구상 클래스의 레퍼런스를 변수에 저장하는 일을 미리 방지합시다. 
2. 구상 클래스에서 유도된 클래스르 만들지 맙시다.
    - 구상클래스에 유도된 클래스를 만들면 특정 구상 클래스에 의존하게 됩니다. 인터페이스나 추상 클래스처럼 추상화된것으로부터 클래스를 만들어야 합니다. 
3. 베이스 클래스에 이미 구현되어 있는 메서드를 오버라이드하지 맙시다. 
    - 이미 구현되어 있는 메서드를 오버라이드 한다면 베이스 클래스가 제대로 추상화되지 않습니다. 베이스 클래스에서 메서드를 정의할 때는 모든 서브 클래스에서 공유할 수 있는 것만 정의해야 합니다. 

<Image
src={`/images/dp/dp_02_factoryMethod02.png`}
width={1440}
height={960}
/>

### 추상 팩토리 패턴 
추상 팩토리 패턴은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공. 구상클래스는 서브 클래스에서 만듬. 
- 추상 팩토리 패턴은 객체 구성을 활용합니다. 팩토리 인터페이스에서 선언한 메소드에서 객체 생성이 구현되죠.
- 구상클래스 의존성을 줄여줌으로 느슨한 결합 

<Image
src={`/images/dp/dp_02_abstractFactory02.png`}
width={1440}
height={960}
/>

- 팩토리를 쓰면 객체 생성을 캡슐화 할 수 있습니다.

### 싱글턴 패턴 
클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공함.
- = ENUM을 사용하기 .